# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Response Format

EVERY response must follow this exact pattern unless explicitly told otherwise:

<index>
- Read and analyze EVERY file in the codebase
- Document current state, issues, and relevant code
- No skipping or assumptions
</index>

<plan>
- Detail exact steps to take
- Consider dependencies and potential issues
- No action without complete understanding
</plan>

<approval seeking>
- Ask for confirmation before proceeding
- Present clear options if applicable
</approval seeking>

<act>
- Only after approval
- Execute planned steps precisely
</act>

# Tools

Note all the tools are in python. So in the case you need to do batch processing, you can always consult the python files and write your own script.

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:

```bash
venv/bin/python tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:

```bash
venv/bin/python tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:

```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot

screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM

response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:

```
venv/bin/python ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:

- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3.5-sonnet-20240620)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.

```
venv/bin/python ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```

This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.

```
venv/bin/python ./tools/search_engine.py "your search keywords"
```

This will output the search results in the following format:

```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```

If needed, you can further use the `web_scraper.py` file to scrape the web page content.

# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Use it.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.
- Don't run migrations for supabase sql in terminal, provide the script instead
- MUST read and analyze the entire codebase for every prompt unless explicitly told not to
- MUST follow the index-plan-approval-act pattern for every response
- Never make assumptions about file existence or content
- Never take action without complete codebase understanding
- Keep git operations simple: check status first, use single-line commits by default, only use complex commit structures when explicitly requested
- Always update scratchpad before making any changes
- Proceed with implementation step by step, marking each microstep as complete
- Get approval before proceeding to next major phase

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- Always verify the actual state of the codebase before updating progress trackers
- Never assume component completion without checking the actual files
- Never mark tasks as complete without verifying each individual file exists and contains the required functionality
- Projects section is implemented as a component rather than a separate page
- Contact form exists as part of services section (ContactServiceCard)
- Blog section needs full implementation but route exists
- Spline is used for 3D background animations
- Keep component organization flat when possible (avoid deep nesting)
- Verify all imports work after moving files
- Clean up empty directories and unused template files
- Keep documentation up to date with actual codebase structure
- Layout spacing should match homepage's rhythm:
  - Main container max-width: 1280px
  - Featured post height: 60vh
  - Grid gaps: 2rem (32px)
  - Card padding: 1.5rem (24px)
  - Section spacing: 4rem (64px)
- Use CSS modules for consistent spacing across components
- Maintain responsive behavior when updating layouts
- Keep grid system flexible for different screen sizes
- For React Router v6 to prepare for v7 migration, add future flags with:
  - `<Router future={{ v7_startTransition: true, v7_relativeSplatPath: true }}>`
- When using Framer Motion scroll animations, ensure containers have non-static positioning:
  - Add `position: 'relative'` to the style prop
  - Or add `className="relative"` for Tailwind projects
  - Or add both for maximum compatibility
- For Framer Motion useScroll hook, the target element needs non-static positioning
- For animations that depend on scroll position, ensure the container has explicit positioning
- Remember that stack context is affected by positioning, so test that z-index works correctly

# Scratchpad

## Latest Updates (2024-03-01)

### React Router and Framer Motion Fixes (March 1, 2024)

[X] Added React Router future flags to prepare for v7 migration

- Added v7_startTransition flag
- Added v7_relativeSplatPath flag
- Fixed warnings related to these upcoming changes

[X] Fixed Framer Motion positioning warnings

- Added relative positioning to ParallaxSection component
- Updated AboutIntro component with proper positioning for scroll animations
- Ensured all containers with scroll animations have non-static positioning

### Navigation Improvements Completed ✅

[X] Blog link scroll-to-top functionality
[X] Projects/Services section navigation from blog page
[X] Correct scroll position for section color changes
[X] Logo hover effect matching navigation numbers

### Current Task: Blog Section Implementation (2024-03-01)

### Project Phases

#### Current Phase: Frontend Implementation

- Using mock data in src/data/blogPosts.js
- Implementing all UI components and interactions
- Setting up routing and navigation
- Creating loading state placeholders

#### Design Phase (To Be Started)

- Match avant-garde theme with arcade accents
- Design elements to implement:
  - Retro-futuristic typography
  - Arcade-style hover effects
  - Neon color accents
  - Grid-based layouts with glitch effects
  - Custom code block styling
  - Animated transitions
  - Pixel art accents
- Create design system for:
  - Typography hierarchy
  - Color palette
  - Animation patterns
  - Interactive elements
  - Loading states

#### Future Phase: Supabase Integration

- Create necessary database tables and relations
- Set up authentication if needed
- Replace mock data with API calls
- Implement proper error handling
- Add loading states
- Update components to handle real data

### Current Implementation Status

#### Phase 1: Basic Infrastructure ✅

[X] Blog types defined
[X] Directory structure created
[X] Basic component files created

#### Phase 2: Blog List Page (Partial) ✅

[X] 2.1. Basic Layout
[X] Featured post section structure
[X] Featured post animations
[X] Basic styling

[X] 2.2. Post Grid
[X] Basic grid layout
[X] Clickable cards
[X] Hover effects
[X] Animations
[X] Navigation implementation

[/] 2.3. Search and Filter (Non-functional)
[X] Search input UI
[ ] Search functionality
[ ] Category filter
[ ] Tag filter
[ ] Final styling (this is a design phase element)

[/] 2.4. Pagination (Incomplete)
[X] Basic pagination UI
[ ] Pagination functionality
[ ] Styling (this is a design phase element)
[ ] Animations (this is a design phase element)

#### Phase 3: Blog Post Page (In Progress)

[X] 3.1. Navigation Implementation
[X] Card to post navigation
[X] URL parameter handling
[X] Back navigation

[/] 3.2. Post Content
[X] Basic data fetching
[X] Proper markdown rendering
[X] Code block highlighting
[ ] Typography finalization (this is a design phase element)

[/] 3.3. Interactive Elements
[X] Share functionality
[X] Tag linking
[X] Related posts

## New Task: Blog Design Update (2024-03-01)

IMPORTANT: NO FUNCTIONALITY CHANGES ALLOWED - PURE STYLING UPDATES ONLY

### Core Design Principles

- Match homepage's avant-garde aesthetic
- Preserve all existing functionality
- Keep all class names and structure intact
- Only modify visual properties
- Use exact typography from homepage:
  - Cormorant (italic) for important accents
  - Pixelify Sans as currently used
  - Maintain existing body text formatting

### Implementation Checklist

#### Phase 1: Typography System [In Progress]

[X] 1.1. Font Audit
[X] Review current font usage in blog components
[X] Document all Cormorant usage in homepage
[X] Document all Pixelify Sans usage in homepage
[X] Map current text elements to new typography system

[X] 1.2. Typography CSS Updates
[X] Create BlogList.module.css with typography styles
[X] Update heading styles to match homepage
[X] Apply Cormorant italic to accent elements
[X] Verify Pixelify Sans usage matches current pattern
[X] Add loading animation to headings (matching homepage)

[X] 1.3. Component Updates
[X] Update Featured Post typography
[X] Update Latest Posts section title
[X] Update blog cards typography
[X] Update search and filters typography
[X] Verify all typography changes preserve functionality

#### Phase 2: Color and Theme [In Progress]

[X] 2.1. Color Palette Implementation
[X] Extract exact colors from homepage
[X] Update background colors
[X] Update text colors
[X] Update accent colors
[X] Implement hover state colors

[X] 2.2. Dark Theme Integration
[X] Apply dark background matching homepage
[X] Update contrast ratios
[X] Verify readability
[X] Match homepage's color transitions

#### Phase 3: Layout and Spacing [In Progress]

[X] 3.1. Grid System
[X] Match homepage's grid spacing
[X] Update padding and margins
[X] Align with homepage's whitespace pattern
[X] Preserve responsive behavior

[X] 3.2. Component Spacing
[X] Update card spacing
[X] Match section padding
[X] Align with homepage's vertical rhythm
[X] Verify mobile responsiveness

#### Phase 4: Animations and Transitions [In Progress]

[/] 4.1. Loading Animations
[X] 4.1.1. Loading Animation Component
[X] Create reusable loading wrapper component
[X] Implement percentage counter with Pixelify Sans font
[X] Add glitch effect to percentage number
[X] Create pixelated progress bar
[X] Match homepage color scheme
[X] Add subtle scan line effect
[X] Implement smooth transitions between states

[X] 4.1.2. Skeleton Loading States
[X] Design arcade-style placeholder cards
[X] Add pulse animation to placeholders
[X] Implement gradient overlay effect
[X] Create pixelated edges for placeholders
[X] Match dark theme colors
[X] Ensure responsive behavior

[X] 4.1.3. Loading Sequence
[X] Implement staggered loading animation
[X] Add loading state management
[X] Create smooth transitions between states
[X] Match homepage timing
[X] Test performance impact

[/] 4.2. Scroll Animations
[X] 4.2.1. Scroll Progress
[X] Create ScrollProgress.module.css for scroll animation styles
[X] Implement ScrollProgress component with fixed position bar
[X] Add subtle pixelated progress indicator design
[X] Ensure smooth progress updates using scroll event listeners
[X] Add to BlogPost component
[ ] Test in different browsers
[ ] Verify mobile compatibility

[/] 4.2.2. Scroll Indicators
[X] Create ScrollIndicators.module.css for indicator styles
[X] Implement ScrollIndicators component with fade in/out logic
[X] Design arcade-style up/down arrows matching aesthetic
[X] Add subtle pulse animation to arrows
[X] Implement with useEffect for proper cleanup
[X] Add to both BlogList and BlogPost components
[ ] Test smooth scrolling behavior

[/] 4.2.3. Scroll-Triggered Animations
[X] Implement useInView hook for scroll detection
[X] Add subtle fade-in animations to content sections
[X] Create staggered reveal effect for list items
[X] Add to BlogPost content sections
[ ] Ensure animations don't interfere with reading
[ ] Test performance impact
[ ] Optimize for lower-end devices

[X] 4.3. Hover Effects
[X] 4.3.1. Card Hover States
[X] Design arcade-style hover feedback
[X] Add subtle scale transform
[X] Implement color transitions
[X] Create border glow effect
[X] Match homepage hover states

[X] 4.3.2. Interactive Elements
[X] Add button hover animations
[X] Implement link hover effects
[X] Create focus state animations
[X] Match theme consistency
[X] Test accessibility

[X] 4.3.3. Transition Effects
[X] Design smooth state transitions
[X] Add micro-interactions
[X] Implement exit animations
[X] Create consistent timing
[X] Test performance impact

[/] 4.4. Performance Optimization
[ ] 4.4.1. Animation Performance
[ ] Audit animation frame rates
[ ] Optimize heavy animations
[ ] Add will-change hints
[ ] Implement throttling where needed
[ ] Test on lower-end devices

[ ] 4.4.2. Mobile Optimization
[ ] Adjust animation complexity
[ ] Optimize touch interactions
[ ] Test on various devices
[ ] Ensure smooth scrolling
[ ] Verify battery impact

[ ] 4.4.3. Browser Compatibility
[ ] Test in Chrome
[ ] Test in Firefox
[ ] Test in Safari
[ ] Add fallback animations
[ ] Verify graceful degradation

#### Phase 5: Final Touches and Verification [Not Started]

[ ] 5.1. Cross-browser Testing
[ ] Test in Chrome
[ ] Test in Firefox
[ ] Test in Safari
[ ] Verify responsive behavior

[ ] 5.2. Performance Check
[ ] Verify animation performance
[ ] Check loading times
[ ] Optimize if needed
[ ] Document any issues

### Safety Checks (To verify after each phase)

- [ ] All functionality remains intact
- [ ] No JavaScript logic modified
- [ ] Component structure unchanged
- [ ] Event handlers preserved
- [ ] Props and state untouched
- [ ] Responsive behavior maintained
- [ ] Accessibility preserved

### Current Status: Layout and Spacing Phase Complete

Next Step: Begin Animations and Transitions Phase

### Latest Changes (2024-03-01)

1. Updated BlogList component with new spacing classes
2. Implemented consistent grid system matching homepage
3. Added proper spacing for all components
4. Maintained responsive behavior
5. Verified mobile layout
6. Created loading animation component with Rick Owens x arcade aesthetic
7. Fixed loading animation issues and made it more professional
8. Implemented skeleton loading states for blog cards and featured posts
9. Added staggered loading sequence with phase transitions
10. Created pixelated edges and scan line effects for loading elements
11. Implemented scroll progress indicator with pixelated design
12. Added scroll indicators for improved navigation
13. Created custom useInView hook for scroll-triggered animations
14. Enhanced blog post content with fade-in and reveal animations
15. Implemented staggered list animations for better reading experience
16. Implemented arcade-style hover effects for cards and interactive elements
17. Added glowing border effect on card hover
18. Created neon flickering effect for headings on hover
19. Implemented smooth link hover animations with animated underlines
20. Enhanced buttons with arcade-style micro-interactions
21. Applied focus state animations for accessibility
22. Added pixelated edge effects on hover
23. Implemented glitch effects for featured post title
24. Enhanced form elements with consistent hover states
25. Optimized animations with will-change for better performance

### Fixed AboutIntro Animations (2024-03-12)

[X] Fixed squares not emerging from bottom when scrolling

- Positioned particles initially below the viewport
- Updated animation calculations to move them into view
- Applied easeOutCubic timing function for natural movement

[X] Fixed scroll text not functioning as intended

- Updated timing points to match main opacity animation
- Simplified animation with more subtle, consistent movement
- Improved text readability with shorter animation durations

[X] Enhanced overall animation behavior

- Added position: 'relative' to container for proper scroll calculations
- Implemented normalized scroll progress relative to section element
- Improved particle visibility during text fade-out
- Added proper dependency array to useEffect hook
- Enhanced cursor interaction with better boundary detection
- Matched timing points between different animations

### Enhanced AboutIntro Animation Dynamics (2024-03-13)

[X] Made particle movement more dynamic and continuous

- Implemented two-phase animation (emergence + continuous floating)
- Added hasEmerged flag to track animation state per particle
- Enhanced particle upward motion based on scroll position
- Increased floating amplitude and variation parameters

[X] Improved floating behavior when scrolling

- Added continuous upward movement combining base speed + scroll acceleration
- Applied higher rotation and scale variation parameters
- Enhanced floating motion with larger amplitudes and varied speeds
- Made cursor interaction more responsive with larger influence radius

[X] Implemented proper animation flow

- Particles now emerge from bottom then continue floating upward with scroll
- Movement continues throughout the entire scroll rather than stopping
- Maintained cursor interaction while improving animation dynamics
- Fixed drawing logic for better performance

### Added Section Transition Animation (2024-03-13)

[X] Implemented bar graph transition animation

- Created staggered bar graph effect that emerges from bottom of section
- Added 7 bars with varying heights and widths (no gaps between them)
- Implemented smooth transition with easeOutExpo timing function
- Synchronized with scroll position for natural emergence

[X] Enhanced transition timing

- Added individual delays for each bar (staggered animation)
- Created smooth height growth animation for each bar
- Applied exponential easing for natural motion
- Ensured proper cleanup of animation frame IDs

[X] Applied responsive design principles

- Made bars scale with screen width
- Used relative sizing for consistent proportions
- Maintained consistent aesthetics across screen sizes
- Matched theme with full-width design

### Next Actions

1. Test all animations across different browsers and devices
2. Perform performance optimization for animations
3. Make mobile-specific adjustments if needed
4. Implement fallback animations for older browsers
5. Document all animation classes in style guide

## Lessons learned

- @apply should not be used with the 'group' utility in Tailwind CSS
- Use vanilla CSS properties when dealing with complex utility combinations
- Add group class directly in JSX when needed
- Keep loading animations subtle and professional to match the avant-garde aesthetic
- Ensure loading components don't interfere with page functionality
- Never stage changes to git before confirming they work with the user
- Fix navigation issues before proceeding with styling enhancements
- Test all interactive elements thoroughly before considering a feature complete
- Use AnimatePresence from framer-motion for smooth exit animations
- Implement staggered loading phases for a more professional loading experience
- Match typography and styling with the homepage for consistent branding
- When using ReactMarkdown, provide custom components for all HTML elements to ensure consistent styling
- For blog content, ensure proper formatting of tables, code blocks, and other markdown elements
- Use the publishedAt field instead of date field for blog post dates
- For consistent image aspect ratios, use the @tailwindcss/aspect-ratio plugin with aspect-w-16 aspect-h-9 classes
- Wrap images in aspect ratio containers to maintain consistent proportions across the site
- When using Tailwind plugins in a Vite project, use dynamic imports with try/catch to handle potential import failures
- For aspect ratios, implement a fallback using padding-bottom percentage (56.25% for 16:9) when plugins aren't available
- Always test plugin installations by restarting the dev server
- Use IntersectionObserver API via custom hooks for efficient scroll-triggered animations
- Keep animation delays short (0.1-0.3s) to maintain responsiveness
- Use different animation types for different content (fade for paragraphs, reveal for headings)
- Implement staggered animations for list items to create a natural reading flow
- Ensure scroll animations don't interfere with content consumption
- Use triggerOnce option to prevent animations from replaying during scrolling
- When implementing hover effects, use will-change property to optimize performance for transforms and opacity changes
- Create reusable hover effect CSS modules that can be composed with existing class names
- For arcade-style button effects, use transform-style: preserve-3d with subtle vertical movements
- Implement focus states for all interactive elements to maintain accessibility
- Use cubic-bezier curves for smoother, more natural transition effects
- Apply subtle glowing effects with box-shadow rather than text-shadow for better performance
- Keep hover effect animations subtle and professional to avoid distracting from content
- Consider adding micro-interactions for better user feedback on interactive elements
- Use CSS pseudo-elements (::before, ::after) for hover effects to avoid cluttering the DOM
- When using CSS Modules with Tailwind's 'group' functionality, use :global(.group:hover) selector to properly select child elements when their parent is hovered
- For card-level hover effects that affect contained elements, replace direct :hover selectors with group-hover patterns for more intuitive user interaction
- When implementing canvas-based animations, ensure particles are positioned initially out of view (below viewport) and animated in
- For scroll-triggered canvas animations, calculate normalized scroll progress relative to the section element rather than entire page
- Add `position: 'relative'` to containers with Framer Motion's useScroll hook to ensure proper tracking
- When using multiple useScroll hooks, ensure consistent offset values across related animations
- For particle animation timing, keep particles visible as text fades out by tying particle visibility to text opacity
- Instead of checking specific opacity values (1, 0), use ranges to handle transitions between states
- Remember to add a dependency array [opacity] to useEffect when animation depends on a motion value
- For scrolling text indicators, use subtle animations with lower duration (1-2s) rather than complex multi-step animations
- Match timing points between different animations (0.85, 1) for consistent fade effects
- For cursor-interactive elements, implement a more natural boundary detection with clear visual feedback
- For canvas particle animations with continuous motion, implement a two-phase approach: initial emergence followed by continuous movement
- Use a hasEmerged flag to track when particles have reached their initial positions and should switch to continuous floating mode
- Make particle animations more dynamic by increasing amplitude, rotation speed, and scale variation parameters
- Apply both constant upward motion and scroll-based acceleration to particles for a dynamic floating effect
- For cursor interaction, apply the force to the final x/y position rather than modifying the base positions to prevent jitter
- Use larger amplitude values (80-120 rather than 30-50) for more noticeable floating movement
- When tracking scroll position, use a combination of normalized scroll progress and custom multipliers for more natural upward flow
- For section transitions, use canvas-based animations for better control over drawing low-level shapes
- When implementing staggered animations, add small delays (0.05-0.1s) between elements for natural flow
- For bar graph transitions, calculate relative widths based on container width to ensure bars fill the entire space
- Use exponential easing (easeOutExpo) for quick initial growth and subtle finishing motion
- Apply transform and opacity transitions together for smoother entries
- For bar graph animations, multiply progress value (progress \* 3) to start animation earlier in the scroll sequence
- Position transition elements with absolute positioning at section boundaries
- Implement proper canvas sizing with resize event listeners for responsive behavior
- When animating heights, draw from bottom up for a rising effect
- Create seamless transitions by having bars touch with no gaps between them
- For canvas animations, always use requestAnimationFrame and clear the animation in cleanup functions

# Process Management

## Version Control

- Version: 2024.03.13.2
- Last Updated: 2024-03-13
- Last Task: Section Transition Animation

## Update Triggers

- New task started
- Major milestone completed
- New component or feature added
- Design decisions made
- Dependencies changed
- Bug fixes implemented

## Update Process

1. Increment version number (YYYY.MM.DD.version)
2. Update "Last Updated" date
3. Update "Last Task" description
4. Check and update all task statuses
5. Add new tasks if necessary
6. Update current focus
7. Document any new lessons learned
8. Clean up completed tasks older than 2 versions

## Task Status Markers

[X] Completed
[/] Partially Complete
[ ] Not Started
[-] Blocked
[>] Deferred
[!] Needs Review

## Current Focus: Section Transition Animation

- Implemented bar graph transition animation at section boundary
- Added staggered emergence of 7 bars with varying heights
- Synchronized with scroll position for natural transition
- Applied smooth easing for professional animation effect
- Integrated with existing AboutIntro animation system
